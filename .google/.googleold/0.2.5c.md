# ðŸ“„ **Mjolnir v0.2.5c Specification â€“ Advanced Dual Screenshot (Root/Shizuku)**

**Version:** 0.2.5c
**Scope:** Implement the "Hidden Power-User" backend for Dual Screenshots using Root or Shizuku.
**Supersedes:** Replaces the implementation strategy of 0.2.5b (MediaProjection) with Shell-based capture.
**UX Philosophy:** "Invisible Feature" â€” The feature exists only if the user has set up the environment (Root or Shizuku). No in-app onboarding UI.

---

# 1. **Overview**

The Dual Screenshot (DSS) feature will be re-architected to bypass Android's high-level `MediaProjection` API, which fails to capture distinct framebuffers on the AYN Thor. Instead, we will use the low-level `screencap` shell command.

To execute this command, the app requires elevated privileges. We will support two methods:
1.  **Shizuku (ADB):** For non-rooted users who have established a local ADB bridge via Shizuku.
2.  **Root (su):** For users with a rooted device.

If neither method is available, the "Dual Screenshot" button in the persistent notification will simply **not appear**.

**Explicit Constraint:** MediaProjection is fully removed and must not be reintroduced.

### **Status Verification**
*   Root-based `screencap` (`su -c screencap -d <id>`) has been tested on the target hardware and is **CONFIRMED WORKING**.
*   It successfully captures distinct framebuffers for both displays, solving the mirroring issue.

---

# 2. **Architecture: The Shell Abstraction**

We will introduce an abstraction layer to decouple the capture logic from the execution method.

## 2.1 `ShellInterface` (Interface)

A minimal contract for executing commands. Do not add extra responsibilities beyond command execution.

```kotlin
interface ShellInterface {
    /**
     * Checks if this provider is currently available/authorized.
     */
    fun isAvailable(): Boolean

    /**
     * Executes a command and returns the output.
     * @throws Exception if execution fails.
     */
    fun execute(command: String): String
    
    /**
     * Executes a binary command (like screencap) and writes stdout to a stream/file.
     */
    fun executeToStream(command: String, outputStream: OutputStream)
}
```

## 2.2 Providers

### `ShizukuShellProvider`
*   **Availability:** Checks if Shizuku service is bound (`Shizuku.pingBinder()`) and permission is granted (`Shizuku.checkSelfPermission()`).
    *   *Constraint:* Availability must verify that Shizuku is **running and reachable**, not just installed. Wireless ADB sessions may die; `pingBinder` is the source of truth.
*   **Execution:** Uses `Shizuku.newProcess(...)`.
*   **Constraint:** Commands must stay within ADB capabilities (e.g., `screencap` works, but accessing protected system files may not).
*   **Note:** Shizuku does not autostart on non-rooted devices; availability checks must handle this gracefully.

### `RootShellProvider`
*   **Availability:** Checks if `su` binary exists and allows access.
*   **Execution:** Uses `Runtime.getRuntime().exec("su -c ...")`.

---

# 3. **Access Discovery (`AccessManager`)**

A singleton `AccessManager` (or `CapabilityManager`) will handle the discovery logic and choose the active provider.

## 3.1 Priority Order
1.  **Shizuku** (If running + granted)
2.  **Root (su)**
3.  **None** (Feature hidden)

## 3.2 Logic Flow
On app startup (and potentially on resume), the manager checks:

1.  **Check Shizuku:**
    *   Is Shizuku installed?
    *   Is the service running?
    *   Do we have permission?
    *   *Result:* If yes, `ActiveProvider = ShizukuShellProvider`.

2.  **Check Root (if Shizuku unavailable):**
    *   Can we execute `su`?
    *   *Result:* If yes, `ActiveProvider = RootShellProvider`.

3.  **Fallback:**
    *   `ActiveProvider = null`.

## 3.3 Persistent Notification State
The `KeepAliveService` must observe `AccessManager`.
*   **If ActiveProvider != null:** Add/Show "Dual Screenshot" action button.
*   **If ActiveProvider == null:** Remove/Hide "Dual Screenshot" action button.

---

# 4. **Capture Implementation**

The `ScreenshotUtil` will be updated to use the `ActiveProvider` from `AccessManager`.

## 4.1 The Command
The capture command remains consistent across providers:

```bash
screencap -d <displayId>
```

## 4.2 Execution Flow
In `DualScreenshotService.performDualCapture()`:

1.  Get `ActiveProvider` from `AccessManager`.
2.  **Discover IDs:**
    *   Run `dumpsys display` (NOT `dumpsys SurfaceFlinger`) via provider.
    *   *Constraint:* IDs are not stable. They must be rediscovered at runtime before every capture attempt.
    *   Parse valid hardware IDs (look for `Display <id>` or `local:<id>`).
3.  **Capture:**
    *   For `topId` and `bottomId`:
        *   Execute `screencap -d <id>` via provider.
        *   Pipe output directly to a temporary file or decode byte stream to Bitmap.
4.  **Stitch & Save:** (Existing logic matches).

---

# 5. **Dependencies**

We need to add the Shizuku API dependencies to `app/build.gradle.kts`.

```kotlin
implementation("dev.rikka.shizuku:api:13.1.5")
implementation("dev.rikka.shizuku:provider:13.1.5")
```

---

# 6. **Refactor Requirements**

1.  **Remove `ScreenshotPermissionActivity`:** It is no longer needed (MediaProjection is dead).
2.  **Clean `DualScreenshotService`:** Remove any lingering MediaProjection code.
3.  **Update `KeepAliveService`:** Add logic to dynamically update the notification actions based on capability checks.
4.  **Adapt to Codebase:** Do not generate parallel structures; integrate cleanly into `xyz.blacksheep.mjolnir.utils`.

---

# 7. **Process**

1.  **Add Dependencies:** specific Shizuku libraries.
2.  **Create Interface:** `ShellInterface`.
3.  **Implement Providers:** Root and Shizuku logic.
4.  **Implement Manager:** Logic to select the best provider.
5.  **Wire to Service:** Update `KeepAliveService` to hide/show button.
6.  **Wire to Capture:** Update `ScreenshotUtil` to use the interface.

This approach ensures we have a robust, extensible foundation for advanced features without cluttering the UI or relying on broken system APIs.
