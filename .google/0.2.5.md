Here’s the full `v0.2.5.md` spec you can drop into your repo (e.g. `docs/v0.2.5.md`).
I’ve baked in the context from the existing architecture and the current `SharedUI.kt`.

---

# Mjolnir v0.2.5 – Full Specification

> **Phased release:**
> **0.2.5a** – Settings refactor & SharedUI breakup
> **0.2.5b** – Dual-Screen Screenshot (DSS) system
> **0.2.5c** – Guided onboarding & DSS gesture integration
> Final public version will be tagged **v0.2.5** after all phases are complete and stable.

This document is the **single source of truth** for v0.2.5. It is **not** a step-by-step task list, but a *design + behavior spec*. Batch instructions to AI agents (e.g. Gemini) will reference this doc.

---

## 0. Global Constraints & Principles

These apply to **all** sub-versions (a, b, c):

1. **Do not change**:

    * Core dual-screen launching behavior (`DualScreenLauncher`, `HomeActionLauncher`, etc.).
    * Gesture detection logic in the AccessibilityService (timing, mappings).
    * Foreground service / KeepAlive architecture, notification channels, or icon prewarm logic.

2. **No BOM / dependency churn**

    * Do **not** change Compose BOM versions or core library versions unless explicitly authorized. Prior attempts caused widespread breakage.

3. **Respect the Thor dual-screen assumptions**

    * Display IDs: 0 = top, 1 = bottom.
    * Multi-display launching must still use `ActivityOptions.setLaunchDisplayId`.

4. **SharedPreferences keys**

    * All keys must come from `Constants.kt`.
    * No hardcoded string keys inside UI/composables.

5. **Performance**

    * No blocking I/O inside Composables.
    * Use existing helpers (`AppQueryHelper`, icon cache) instead of re-querying package manager in UI.

6. **Imports discipline**

    * Whenever a new type, function, or extension is used, **explicit imports must be added**.
    * Do not assume the IDE or tooling “will add them later”.
    * If code references `SettingsMenuScaffold`, `SettingsSectionHeader`, etc., ensure the corresponding imports are present.

7. **Source of truth for behavior**

    * If spec and existing code disagree, **this document wins** for behavior of new features.
    * For legacy behavior (home gestures, dual launch, diagnostics), preserve existing behavior unless this doc explicitly calls for a change.

---

## 1. Release Breakdown & Goals

### 1.1 v0.2.5a – Settings Refactor / SharedUI Breakup

Goals:

* Replace the monolithic `SharedUI.kt` with **modular settings files**.
* Introduce a **shared settings scaffold DSL** (`SettingsMenuScaffold`) to standardize menu structure.
* Preserve all existing behaviors & UX (home settings, blacklist, diagnostics, Steam file generator, etc.).
* Prepare the codebase for:

    * DSS settings (0.2.5b / 0.2.5c).
    * Guided onboarding (0.2.5c).

Non-goals:

* No UX redesign beyond layout cleanup.
* No onboarding changes yet.
* No DSS implementation yet.

---

### 1.2 v0.2.5b – Dual-Screen Screenshot (DSS) Foundation

Goals:

* Implement **Dual-Screen Screenshot (DSS)** feature:

    * Capture display 0 (top) and display 1 (bottom) via MediaProjection.
    * Stitch vertically, center-aligned.
    * Save a single PNG into a predictable folder.
    * Optional: auto-open share sheet.
* Provide a **Quick Settings tile** as the primary entry point.
* Add minimal settings for DSS (e.g., “Open share sheet after capture”).

Non-goals:

* No gesture bindings yet.
* No complex UI for history, previews, or advanced formats.
* No changes to home interception or accessibility timing.

---

### 1.3 v0.2.5c – Onboarding & DSS Gesture Integration

Goals:

* Replace the “read a guide / bounce between screens” onboarding with a **guided flow** that:

    * Knows whether this is a fresh install or an update.
    * Guides users step-by-step through:

        * Notification permission
        * Accessibility service
        * Home interception
        * Home launcher configuration
        * (Optionally) DSS configuration
    * Directly navigates to specific settings submenus instead of telling users to manually find them.
* Integrate DSS into the experience:

    * Add an optional gesture mapping for DSS (e.g., mapping one of the existing gesture actions to “Dual Screenshot”).
    * Ensure DSS feels like a native part of Mjolnir’s “toolset” rather than a random extra.

Non-goals:

* No large visual rebrand.
* No full re-architecture of navigation outside settings/onboarding.
* No change to underlying KeepAlive or app process behavior.

---

## 2. v0.2.5a – Settings Refactor & SharedUI Breakup

### 2.1 Current Situation (as of `SharedUI.kt`)

`SharedUI.kt` currently contains:

* **Enums / state savers**

    * `AppTheme`
    * `MainScreen`
    * `UiState` + `UiStateSaver` for Steam file generator.

* **Reusable components**

    * `AppSlotCard`
    * `rememberDrawablePainter`
    * `Intent.getPackageIcon`
    * `SettingsItem`
    * `ManualInputUi`
    * `SearchUi`
    * `SummaryRow`
    * Various dialogs (`AboutDialog`, `OverwriteConfirmationDialog`, etc.).

* **Navigation & top-level settings structure**

    * `SettingsScreen(...)` (overloaded)
    * Internal `NavHost` with routes: `"main"`, `"tool_settings"`, `"appearance"`, `"home_launcher"`, `"app_blacklist"`, `"developer_mode"`, `"about"`, `"diagnostics_summary"`.

* **Multiple full screens/menus**

    * `MainSettingsScreen` (main menu)
    * `ToolSettingsScreen` (Steam File Generator)
    * `AppearanceSettingsScreen`
    * `BlacklistSettingsScreen` + `AddAppToBlacklistDialog`
    * `HomeLauncherSettingsMenu` (Mjolnir home settings)
    * `DeveloperSettingsScreen`
    * `DiagnosticsSummaryScreen`
    * `HomeSetup`
    * `SetupScreen` (Steam FG setup)

* **Helpers**

    * `getLaunchableApps`
    * `launchOnDualScreens`
    * `getAppIcon`
    * `handleAppSelection`

This is too much for a single file, and is the primary source of UI tech debt.

---

### 2.2 Target Architecture for Settings & Menus

We’re moving to a **modular, DSL-style, Compose-idiomatic architecture**:

#### 2.2.1 Core Concepts

1. **SettingsMenuScaffold**
   A shared composable that provides:

    * Top app bar with title and back navigation.
    * Optional `actions` slot for custom buttons in the top bar.
    * Common padding, background, and layout for menu content.

2. **Per-menu files**
   Each major menu/screen gets its own file, with a composable like:

   ```kotlin
   @Composable
   fun HomeLauncherSettingsMenu(...) { ... }
   ```

   That composable uses `SettingsMenuScaffold` internally and delegates to per-menu content functions.

3. **Reusable components**
   Shared components (e.g. `SettingsItem`, `AppSlotCard`) are moved into a `components` package so multiple menus can reuse them.

4. **Settings navigation graph**
   The NavHost that used to live inside `SharedUI.kt` will be moved to a dedicated `SettingsNavGraph` file, which wires up the modular menus.

---

### 2.3 Expected File Layout After 0.2.5a

Suggested directory structure (exact package paths may vary slightly but should remain consistent):

```text
mjolnir/
  settings/
    SettingsNavGraph.kt            // replaces old SettingsScreen+NavHost
    SettingsMenuScaffold.kt        // shared top-bar + layout DSL

    components/
      SettingsItem.kt
      AppSlotCard.kt
      BlacklistDialogs.kt
      SteamSearchComponents.kt
      DiagnosticsSummaryComponents.kt
      // (other reusable UI blocks as needed)

    main/
      MainSettingsMenu.kt          // replaces MainSettingsScreen

    home/
      HomeLauncherSettingsMenu.kt  // extracted from SharedUI

    appearance/
      AppearanceSettingsMenu.kt

    steam/
      SteamFileSettingsMenu.kt     // from ToolSettingsScreen
      SteamSetupScreen.kt          // from SetupScreen
      SteamOverwriteDialog.kt      // OverwriteConfirmationDialog

    blacklist/
      BlacklistSettingsMenu.kt

    developer/
      DeveloperSettingsMenu.kt

    diagnostics/
      DiagnosticsSummaryScreen.kt

    about/
      AboutDialogScreen.kt         // or keep a dialog composable reused

    onboarding/
      HomeSetupScreen.kt           // from HomeSetup
      (Future: Guided onboarding flow in 0.2.5c)
```

> Note: Names don’t have to be exact, but **each logical menu must have its own file** and must not live in one giant file again.

---

### 2.4 SettingsMenuScaffold Specification

`SettingsMenuScaffold` is a shared DSL for settings screens.

**Signature (conceptual):**

```kotlin
@Composable
fun SettingsMenuScaffold(
    title: String,
    navController: NavController,
    actions: @Composable RowScope.() -> Unit = {},
    content: @Composable ColumnScope.() -> Unit
)
```

**Requirements:**

* Uses `Scaffold` with a `TopAppBar`.
* Top app bar:

    * Shows `title` string.
    * Provides back navigation via `navController.popBackStack()` by default.
    * Renders `actions` in the `TopAppBar.actions`.
* Body:

    * A `LazyColumn` or `Column` with standard padding (`16.dp` horizontal, ~`20.dp` vertical).
    * Wraps `content()` in a `ColumnScope`, so menu content can stack vertically.

**Custom actions:**

Menus that currently customize the top bar (e.g., “Filter Apps” in Home launcher) must pass those buttons via the `actions` slot; the behavior must be preserved.

---

### 2.5 Per-Menu Requirements (0.2.5a)

All these are **refactors**, not feature changes.

#### 2.5.1 Main Settings Menu

* Extract `MainSettingsScreen` into `MainSettingsMenu.kt`.
* Use `SettingsMenuScaffold(title="Settings", ...)`.
* Keep all items:

    * “Mjolnir Home Settings” → route `"home_launcher"`.
    * “Steam File Settings” → `"tool_settings"`.
    * “Appearance” → `"appearance"`.
    * “About” → `"about"`.
* Developer Mode item stays commented out unless specifically reenabled.

#### 2.5.2 Home Launcher Settings Menu

* Extract `HomeLauncherSettingsMenu` + its `LazyColumn` contents into `home/HomeLauncherSettingsMenu.kt`.
* Use `SettingsMenuScaffold(title="Home Launcher", ...)` **with actions**:

    * Preserve the `TextButton` that toggles `showAllApps` (“Filter Apps” / “Remove App Filter”).
* Maintain:

    * Top/bottom app selection with `AppSlotCard`.
    * `<Nothing>` option from `getLaunchableApps`.
    * Main screen radio buttons (`MainScreen.TOP` / `BOTTOM`).
    * App blacklist navigation item (“App Blacklist”).
    * All home button behavior selection rows (single/double/triple/long).
    * Double-tap delay toggle + slider.
    * Diagnostics toggle, max log size segmented buttons, summary/ export/clear, etc.
    * Focus lock workaround toggle & overlay permission handling.
    * “Set default home” button.
* All shared helpers (e.g., `handleAppSelection`, `getLaunchableApps`) should be moved to a shared location (e.g., `home/HomeLauncherHelpers.kt` or `settings/utils/`). Calls must be updated accordingly.

#### 2.5.3 Appearance Settings Menu

* Extract `AppearanceSettingsScreen` to `appearance/AppearanceSettingsMenu.kt`.
* Use `SettingsMenuScaffold(title="Appearance", ...)`.
* Preserve:

    * Theme selection segmented buttons (`AppTheme`).
* No behavior change.

#### 2.5.4 Steam File Generator Settings

* Extract `ToolSettingsScreen` into `steam/SteamFileSettingsMenu.kt`.

* Use `SettingsMenuScaffold(title="Steam File Generator", ...)`.

* Keep:

    * Confirm delete toggle.
    * Auto-create file toggle.
    * ROM directory display + “Change Directory” button.

* Extract `SetupScreen` into `steam/SteamSetupScreen.kt`.

* Maintain `UiState`, `UiStateSaver`, Steam search components (`ManualInputUi`, `SearchUi`) but move them into `steam` package, keeping behavior identical.

#### 2.5.5 Blacklist Settings

* Extract `BlacklistSettingsScreen` and `AddAppToBlacklistDialog` into `blacklist/BlacklistSettingsMenu.kt` (and possibly `BlacklistDialogs.kt`).
* Use `SettingsMenuScaffold(title="App Blacklist", ...)`.
* Behavior to preserve:

    * Reads and writes the `KEY_APP_BLACKLIST` string set in `SharedPreferences`.
    * Uses `AppQueryHelper.queryCanonicalApps()` to populate app list.
    * Shows current blacklisted apps with icon and label.
    * Floating action button opens add dialog.
    * Dialog lists non-blacklisted apps and allows tap to add.
    * “Remove” button removes an app from the blacklist.

#### 2.5.6 Developer Mode Settings

* Extract `DeveloperSettingsScreen` into `developer/DeveloperSettingsMenu.kt`.
* Use `SettingsMenuScaffold(title="Developer Mode", ...)`.
* Preserve toggle and behavior exactly.

#### 2.5.7 Diagnostics Summary

* Extract `DiagnosticsSummaryScreen` into `diagnostics/DiagnosticsSummaryScreen.kt`.
* Use `SettingsMenuScaffold(title="Diagnostics Summary", ...)`.
* Maintain:

    * Summary data derived from `DiagnosticsSummary`.
    * Info card (status, file existence, size, last modified, path).
    * Buttons:

        * View raw log (ACTION_VIEW).
        * Export with summary (ACTION_SEND).
        * Delete active log.
    * Toasts on errors and deletion.

#### 2.5.8 About Dialog

* Extract `AboutDialog` into `about/AboutDialogScreen.kt` or keep as `@Composable fun AboutDialog(...)` in `about/`.
* It may still be used as a dialog inside the settings NavHost or turned into a full screen, at your discretion, but behavior must be preserved:

    * Show version name.
    * Clickable GitHub URL that opens browser.

#### 2.5.9 Home Setup

* Extract `HomeSetup` into `onboarding/HomeSetupScreen.kt`.

* Behavior unchanged in 0.2.5a:

    * Explains notification permission.
    * Explains accessibility service.
    * Explains home interception.
    * Provides “Test Notification” and “Close”.

* This will become part of the new onboarding flow in 0.2.5c.

---

### 2.6 Settings Navigation Graph (0.2.5a)

* Replace the inline `NavHost` currently living inside `SettingsScreen(...)` with a dedicated `SettingsNavGraph.kt`.

`SettingsNavGraph` responsibilities:

* Owns the `NavHost` for settings routes.
* Defines routes:

    * `"main"`
    * `"home_launcher"`
    * `"tool_settings"`
    * `"appearance"`
    * `"app_blacklist"`
    * `"developer_mode"` (if used)
    * `"about"`
    * `"diagnostics_summary"`
    * `"home_setup"` (if onboarding wants to use it)
* Composes the new modular screens from their respective modules.
* Provides a single entrypoint:

  ```kotlin
  @Composable
  fun SettingsScreen(
      startDestination: String = "main",
      // plus the existing callback/param interfaces as needed
  )
  ```

Existing external callers of `SettingsScreen` must continue to work with minimal changes (signature can be adjusted if necessary, but behavior must remain equivalent).

---

### 2.7 Completion Criteria for 0.2.5a

v0.2.5a is **complete** when:

1. `SharedUI.kt` is deleted or reduced to only thin helpers that are truly shared (ideally 0).
2. All settings-related screens live in modular files under `settings/`.
3. `SettingsMenuScaffold` is used by all regular settings menus (except those purposefully kept custom, like `DiagnosticsSummaryScreen` if needed).
4. The app builds and runs without crashes.
5. All previously working menu behaviors still work:

    * Home launcher configuration, blacklist, diagnostics, Steam file generation, appearance, etc.
6. No references to outdated or removed components exist.

---

## 3. v0.2.5b – Dual-Screen Screenshot (DSS) Foundation

This is the **first version of the Dual-Screen Screenshot system**.

### 3.1 High-Level Behavior

DSS should:

* Capture both displays (display 0 = top, display 1 = bottom) using MediaProjection.
* Create a **single image**:

    * Top screenshot on top.
    * Bottom screenshot below.
    * Both centered horizontally in the final bitmap.
    * Transparent background if widths differ.
* Save to a consistent folder in shared media:

    * e.g., `Pictures/Mjolnir/Screenshots`.
* Show a success toast.
* Optionally auto-open the share sheet after capture (controlled by a setting).

Primary trigger: **Quick Settings tile** (no gestures yet).

---

### 3.2 DSS Components

New files to be introduced:

1. `DualScreenshotTileService.kt`
2. `ScreenshotPermissionActivity.kt`
3. `DualScreenshotService.kt` (foreground service)
4. `BitmapStitcher.kt` (utility)
5. Keys & settings:

    * `KEY_DSS_SHARE_AFTER_CAPTURE`
    * `KEY_DSS_PROJECTION_DATA` (or equivalent storage mechanism)

**Note:** actual key names must be defined in `Constants.kt`.

---

### 3.3 User Flows

#### 3.3.1 First-Time Use (Permission Not Granted)

1. User taps “Dual Screenshot” quick tile.

2. Tile checks for stored MediaProjection data.

    * If not present:

        * Launches `ScreenshotPermissionActivity`.

3. `ScreenshotPermissionActivity`:

    * Uses `MediaProjectionManager` to show system capture dialog.
    * On success:

        * Stores `resultCode` + projection `Intent` (serialized via `Intent.toUri(0)` or similar).
        * Finishes.
        * After ~1 second delay (to let notification shade hide), starts `DualScreenshotService`.
    * On failure:

        * Shows short toast (“Dual-screen screenshot requires permission.”).
        * Finishes.

4. `DualScreenshotService`:

    * Constructs `MediaProjection` from stored data.
    * Captures display 0 and display 1 into bitmaps.
    * Uses `BitmapStitcher` to combine them.
    * Saves PNG to `Pictures/Mjolnir/Screenshots`.
    * Adds the file to MediaStore.
    * If `KEY_DSS_SHARE_AFTER_CAPTURE == true`, shows share sheet.
    * Stops itself.

#### 3.3.2 Subsequent Uses (Permission Already Granted)

1. User taps tile.
2. Tile finds stored projection data.
3. Starts `DualScreenshotService` directly.
4. Same capture/save/share process as above.

---

### 3.4 Display Capture Logic

Core requirements:

* Use `DisplayManager` to fetch `Display` objects for ID 0 and 1.
* For each display:

    * Read width, height, density.
    * Create `ImageReader` with RGBA_8888 (or equivalent).
    * Create `VirtualDisplay` via `MediaProjection.createVirtualDisplay`, using the `ImageReader.surface`.
    * Wait for one frame via listener or `acquireLatestImage`.
    * Convert to `Bitmap`.
    * Clean up `Image`, `ImageReader`, and `VirtualDisplay`.

**Error handling:**

* If projection data is invalid or missing:

    * Service should:

        * Stop cleanly.
        * Show a toast: “Screenshot permission expired. Tap again to re-enable.”
    * Next tile tap should trigger permission flow again.

* If display 1 does **not** exist (e.g. running on a non-Thor device):

    * DSS should **fail**, not silently fall back to single-screen capture.
    * Show toast: “Dual-screen capture requires two displays.”

---

### 3.5 Bitmap Stitcher

`BitmapStitcher.kt` should:

* Take two non-null `Bitmap` instances: `topBitmap` and `bottomBitmap`.
* Output width = `max(top.width, bottom.width)`.
* Output height = `top.height + bottom.height`.
* Use a transparent background.

Placement:

* Top bitmap:

    * Centered horizontally, at y = 0.
* Bottom bitmap:

    * Centered horizontally.
    * y = `top.height`.

Hard requirement:
**Both bitmaps centered horizontally. Left alignment is not acceptable.**

---

### 3.6 Storage & Sharing

* Folder: `Pictures/Mjolnir/Screenshots/` (or similar under `Environment.DIRECTORY_PICTURES`).
* Filename format: `DSS_YYYYMMDD_HHMMSS.png`.
* Use `MediaStore` APIs consistent with recent Android versions so gallery apps see the file immediately.
* When auto-sharing is enabled:

    * Share intent type: `"image/png"`.
    * Use `FileProvider` or a MediaStore URI.
    * Offer system chooser so user can pick Discord, Reddit, Messages, etc.

---

### 3.7 Settings Integration (0.2.5b)

Minimal addition:

* New toggle in an appropriate settings submenu (likely Home or a new “Screenshots” area):

  ```
  [ ] Automatically open share sheet after capture
  ```

* Preference key: `KEY_DSS_SHARE_AFTER_CAPTURE` (defined in `Constants.kt`).

* Default value: `false`.

No onboarding or deep integration yet; this will come in 0.2.5c.

---

### 3.8 Out-of-Scope for 0.2.5b

Do **not** implement the following yet:

* Gesture bindings for DSS.
* Screenshot history viewer.
* Compression options / file format toggles.
* Video recording / GIF capture.
* Overlay countdown or advanced UI.

DSS in 0.2.5b is a **clean, minimal, production-ready screenshot pipeline** triggered from a tile.

---

## 4. v0.2.5c – Guided Onboarding & DSS Gesture Integration

### 4.1 Goals

* Replace the “read a guide, bounce around manually” onboarding with a **guided, state-aware flow**.

* Support **both**:

    * New installs.
    * Updates from previous versions.

* Integrate DSS into the overall “Mjolnir as the Thor’s toolset” narrative, if appropriate.

---

### 4.2 Onboarding Requirements

#### 4.2.1 State Awareness

On first run of 0.2.5c, Mjolnir should detect:

* Is this a fresh install?

    * No known preferences set.
    * No top/bottom home apps chosen.
    * Accessibility service likely disabled.
* Is this an upgrade from earlier versions?

    * Some preferences may already exist (home apps, gestures).
    * Accessibility service may or may not be enabled.
    * Home interception may or may not be active.

The onboarding flow should adapt:

* Fresh install: full guided run.
* Upgrade:

    * Offer to review key settings.
    * Skip over already-complete steps.

#### 4.2.2 Steps to Guide Through

Minimum steps:

1. **Notification permission**

    * Explain why the persistent notification exists (KeepAliveService, process anchoring).
    * Provide button to open system dialog if needed.

2. **Accessibility service**

    * Explain Mjolnir’s use of Accessibility (home interception, benefits over default home screen launchers).
    * Provide button to open Android accessibility settings, highlighting Mjolnir’s service.

3. **Home interception toggle**

    * Explain what “home interception” is and why it matters (ability to send user to a dual-screen home experience, app switcher support).
    * Provide a UI element that toggles the preference and/or navigates to the settings screen where it can be controlled.

4. **Home launcher configuration**

    * Guide user to choose:

        * Top screen app.
        * Bottom screen app.
        * Main screen (top or bottom).
    * This step should **programmatically navigate** to the `HomeLauncherSettingsMenu` rather than telling the user to find it themselves.

5. **Optional: DSS overview (if DSS enabled in this build)**

    * Explain what DSS does.
    * Optionally offer a quick test:

        * Direct them to enable the quick tile.
        * Or show where the screenshot settings live.

The onboarding flow may re-use existing screens (`HomeSetup`, `HomeLauncherSettingsMenu`, etc.) but should control navigation for the user rather than dumping them into an unstructured settings maze.

---

### 4.3 Navigation Requirements for Onboarding

The new settings architecture (0.2.5a) must support:

* Programmatic navigation to submenus, e.g.:

  ```kotlin
  navController.navigate("home_launcher")
  navController.navigate("appearance")
  navController.navigate("app_blacklist")
  navController.navigate("diagnostics_summary")
  ```

* Onboarding flow should be able to:

    * Launch settings with a specific start destination.
    * Or integrate directly with the `SettingsNavGraph` to drive step-by-step progress.

Example:

```kotlin
SettingsScreen(startDestination = "home_launcher", ...)
```

or an onboarding controller that holds internal step state and invokes submenus accordingly.

---

### 4.4 DSS Gesture Integration (0.2.5c)

Once DSS is stable (0.2.5b), we integrate it with existing gesture mapping.

**Conceptual approach:**

* Add a new `Action` enum value (if not already present), e.g. `DUAL_SCREENSHOT`.
* Allow the user to map one of:

    * Single press
    * Double tap
    * Triple tap
    * Long press

to `DUAL_SCREENSHOT`.

* When `HomeKeyInterceptorService` detects that action, it must:

    * Trigger the **same pipeline** used by the tile:

        * i.e., fire an intent to start the DSS service, reusing the projection data.
    * If projection permission isn’t available, fallback to prompting the user (e.g., open the tile or future DSS settings screen).

**Constraints:**

* Do not change gesture detection timing (already tuned).
* Do not add new gesture types beyond the existing ones (single/double/triple/long).
* Do not introduce complex UI directly from the AccessibilityService (must use activities/services).

---

## 5. Versioning & Process Notes

### 5.1 Branching and Version Names

* Work for 0.2.5 should be done on dedicated branches:

    * `release/0.2.5a`
    * `release/0.2.5b`
    * `release/0.2.5c`
* `app/build.gradle.kts`:

    * `versionName` should match the sub-version during development (e.g., `"0.2.5a"`).
    * `versionCode` should always increment.

**Note:** Automated tools (like Gemini) are **not allowed** to run git commands; they must ask the user to perform branch changes and provide the exact commands.

---

### 5.2 AI Agent Usage (ChatGPT / Gemini)

* **ChatGPT**:

    * Handles **analysis and code generation** for new modules, especially large refactors like SharedUI breakup.
    * Produces full file contents and refactor plans.
    * Must be careful to include required import statements.

* **Gemini**:

    * Takes the generated code files and **integrates them** into the project.
    * Creates, moves, and deletes files as instructed.
    * Resolves imports and project-level wiring (navigation, Gradle sync).
    * Must not attempt to parse or refactor massive files like the original `SharedUI.kt` on its own.

---

### 5.3 Imports & Compilation Hygiene

* Any time a new file uses:

    * `NavController`
    * `RowScope`, `ColumnScope`
    * `Scaffold`, `TopAppBar`
    * `IconButton`, `TextButton`, etc.

  The corresponding imports from `androidx.compose.*` and other packages must be explicitly added at the top of the file.

* Extension functions moved out of `SharedUI.kt` (e.g., `Intent.getPackageIcon`) must:

    * Be declared in a file with the correct package name.
    * Be imported wherever they’re used.

* After each batch of changes:

    * The project must build successfully.
    * Any missing import or unused import warnings should be resolved.

---

## 6. Summary

**v0.2.5** is a three-part release focused on:

* **0.2.5a:** Cleaning up the settings architecture by breaking `SharedUI.kt` into modular, reusable components and screens, supported by a new `SettingsMenuScaffold` DSL.
* **0.2.5b:** Implementing a robust, minimal **Dual-Screen Screenshot (DSS)** system with a quick tile entry point and simple storage/sharing controls.
* **0.2.5c:** Building a **guided onboarding** flow that leverages the new settings architecture and DSS system, and integrating DSS into gesture mappings.

This spec describes:

* What each phase is responsible for.
* How new components should be architected.
* How existing behavior must be preserved.
* How new behavior (DSS, onboarding) must function.

All implementation work and batch instructions to tooling must respect the constraints and behaviors documented here.

---

---

## Addendum – v0.2.5a Refactor Safety Rules (Critical)

This addendum exists because a previous attempt to modularize `SharedUI.kt` caused massive breakage (360+ errors, lost enums, broken references, behavior changes). These rules are non-negotiable for any future 0.2.5a work.

### 0. Scope Clarification for 0.2.5a

**0.2.5a is a pure extraction / relocation refactor.**

For 0.2.5a:

- We are **not changing behavior**.
- We are **not changing UX flow**.
- We are **not changing the wording of labels, buttons, text, or links**.
- We are **not changing the theme engine, latency values, defaults, or any logic**.
- We are **not introducing new features**.
- We are **not adding new settings**.
- We are **not swapping UI controls (e.g., dropdown → radio buttons)**.
- We are **not adding new URLs, Discords, or external links**.

The **only** allowed changes in 0.2.5a are:

1. Move composables out of `SharedUI.kt` into separate files (`MainSettingsMenu`, `HomeLauncherSettingsMenu`, etc.).
2. Wire them up so the rest of the app calls the new composables instead of the old ones.
3. Update imports and references accordingly so everything compiles.
4. Delete `SharedUI.kt` **only after** all migrated screens compile and behave identically.

If a change is not strictly required to accomplish (1)–(4), it is out of scope for 0.2.5a.

### 1. No Silent Redesigns or “Improvements”

For 0.2.5a:

- **Do NOT:**
    - Replace dropdowns with radio groups.
    - Replace sliders with generic sliders if that loses the original stepping behavior (e.g., 25 ms increments).
    - Change button text (e.g., “Set default home” vs “Set as default home”).
    - Add new settings like “Dynamic Colors” unless explicitly specified.
    - Change what happens when a button is pressed.
    - Change how Steam File Generator works.
    - Change diagnostics behavior.
    - Change navigation entry points (e.g., MainActivity should behave exactly the same).
    - Insert placeholder URLs where a real one already exists.

- **Do:**
    - Preserve all existing behavior, even if it looks “non-idiomatic”.
    - Preserve all existing wording, typos included, unless the spec explicitly authorizes a change.

If the spec is silent about UX, that means: **copy the existing UI exactly as-is.**

### 2. Core Types Must Not Be Moved, Recreated, or Renamed

The previous refactor blew up because enums and constants were moved or recreated. For 0.2.5a:

- **Do NOT:**
    - Delete `Action`, `MainScreen`, `AppTheme`, `Gesture`, or any existing enums.
    - Move enums into a different package unless the spec explicitly says so.
    - Create new versions of these enums in new packages and update references to them.
    - Create new `Constants` objects in competing packages and then “consolidate” references.

- If an enum or core object seems to be “missing” or “in the wrong place”:
    - **STOP.**
    - **Flag the user** and ask where it actually lives and how it should be referenced.
    - Do not guess.

### 3. State Classes (like UiState) Must Not Be Duplicated or Renamed Blindly

The `UiState` redeclaration mess is explicitly banned going forward.

- **Do NOT:**
    - Create a second `UiState` in another file just to make something compile.
    - Rename existing state classes (e.g., to `SearchState`) without explicit instruction from the user.
    - Create “temporary” state classes to paper over unresolved references.

- If a state class conflicts (e.g., two `UiState` in the same package):
    - **STOP.**
    - Show the conflict and ask the user which one is canonical and how to split responsibilities.

### 4. No New Helper Files Unless Explicitly Requested

- **Do NOT:**
    - Invent `*Helpers.kt` files (e.g., `HomeLauncherHelpers`, `SteamUiState`, etc.) unless the spec clearly includes them.
    - Generate new helpers just because you see repeated logic.
    - Move logic from existing helpers (`AppQueryHelper`, `DualScreenLauncher`, `SteamTool`, etc.) unless instructed.

- When instructions say “use existing helper X”:
    - Open that file.
    - Match the actual function signatures.
    - Call those functions — **do not invent new signatures**.

If a call site would require a new helper or a new signature, and the spec did not mention that, flag the user instead of generating it.

### 5. Imports, References, and APIs: No Guessing

The refactor previously created hundreds of errors because imports and method names were guessed.

For 0.2.5a:

- When calling a method on an existing utility (`SteamTool`, `DualScreenLauncher`, `DiagnosticsLogger`, etc.):
    - Open the actual file.
    - Use the **existing** function names and parameters.
    - Do not invent new methods (e.g., `createSteamFile()` when only `createSteamFileFromDetails()` exists).

- After each batch of changes:
    - Run a compile / analysis pass.
    - If you see:
        - More than a handful (say > 10) unresolved references, or
        - Any redeclaration errors,
    - **STOP.**
    - Do not auto-generate new files or rename classes to “fix” it.
    - Present the user with:
        - A short list of the unresolved symbols.
        - Your best guess about why they’re unresolved (missing import vs missing file vs wrong package).
        - A direct question asking how they want to resolve it.

### 6. Alignment With Spec vs. Instructions

If there is any mismatch between:

- The instructions given to you (e.g., “modularize settings, don’t change behavior”), and
- The operations you’re about to perform (e.g., changing UI controls, changing navigation entrypoints, inventing new links),

You must treat that as an error.

For 0.2.5a:

- If instructions from the assistant conflict with the written spec in `0.2.5.md`, **the spec wins.**
- In that case:
    - **STOP.**
    - Show the user the conflicting instruction and the relevant part of the spec.
    - Ask which interpretation they want to follow.

### 7. Global Scaffolding Is Allowed in Principle, But Not at the Cost of Fidelity

The idea of having a shared `SettingsMenuScaffold` or similar is acceptable **only if**:

- It does not change the UI elements, text, layout, or behavior of existing screens.
- It can be introduced by **wrapping** the existing content, not rewriting it.

If a shared scaffold would require changing controls (e.g., turning dropdowns into radios, changing paddings, altering button layout), that change is **out of scope for 0.2.5a**.

0.2.5a may introduce scaffolding **only if** the resulting screens are pixel- and behavior-equivalent to the originals.

---

You must follow these rules for all 0.2.5a work.

1. Before any changes:
    - Open and read `.google/0.2.5.md` in full, including the Addendum section.
    - Treat that file as the single source of truth for scope and constraints.
    - If any later instructions from the assistant conflict with that spec, the spec wins.

2. Scope of 0.2.5a:
    - 0.2.5a is ONLY about extracting existing composables out of SharedUI.kt into separate files and updating references.
    - You are NOT allowed to:
        - Change behavior.
        - Change UI control types (e.g., dropdown → radio).
        - Change any user-facing text.
        - Change which screen the app launches into.
        - Change themes or how themes are applied.
        - Add new URLs, Discords, or external links.
        - Introduce new settings, toggles, features, or flags.
    - If the spec is silent on design: port the current implementation literally as it exists in SharedUI.

3. Core types and constants:
    - Do NOT move, delete, or recreate enums like Action, AppTheme, MainScreen, Gesture.
    - Do NOT create new Constants objects or move existing constants into new packages.
    - Use existing imports and packages for core types unless the spec specifically tells you to change them.
    - If you do not see where a core type is defined, STOP and ask the user where it lives. Do not guess.

4. Helpers and utilities:
    - Do NOT create new “helper” files unless the assistant or spec explicitly instructs you to.
    - When you see calls to helpers like AppQueryHelper, DualScreenLauncher, SteamTool, DiagnosticsLogger, etc:
        - Open those files.
        - Use their actual function names and signatures.
        - Do NOT invent new methods or change their signatures.
    - If a call site refers to a method that doesn’t exist:
        - STOP and show the mismatch to the user.
        - Ask whether they want to adjust the call site or extend the helper, and how.

5. State classes:
    - Do NOT create duplicate UiState classes in different files to make errors go away.
    - Do NOT rename UiState or other state classes unless explicitly instructed to by the user.
    - If there is a name collision (e.g., two UiState in the same package):
        - STOP and ask the user which one is canonical and how they want to split responsibilities.

6. Error thresholds and stopping rules:
    - After each batch of edits you apply:
        - Run a check for compilation issues or static analysis errors.
    - If you see:
        - More than 10 unresolved reference errors, OR
        - Any redeclaration/conflicting class/duplicate symbol errors,
        - Do NOT attempt to “auto-fix” by generating new files, new helpers, or renaming classes.
    - Instead:
        - Collect a short list of the problematic symbols and where they occur.
        - Present that list to the user.
        - Explicitly ask: “How do you want to resolve these specific issues?”

7. Alignment with spec vs. instructions:
    - If the assistant tells you to make a change that would:
        - Alter behavior,
        - Change UI semantics,
        - Introduce new external links,
        - Change default values,
        - Or otherwise contradict the Addendum,
          you must:
            - NOT perform that change automatically.
            - Show the instruction and the conflicting part of the spec to the user.
            - Ask which one to obey.

8. Shared scaffolding:
    - You MAY use a shared scaffold like SettingsMenuScaffold ONLY if:
        - Wrapping existing content does not change layout, controls, or behavior.
        - You do not swap controls, change text, or remove options.
    - If applying a global scaffold would alter any UI or behavior, that scaffold change is out of scope for 0.2.5a. Do not do it.

9. User involvement:
    - When in doubt about behavior, scope, or the meaning of the spec:
        - STOP.
        - Ask a direct, concrete question.
        - Wait for the user’s answer before continuing.

10. If at any point you realize that you would need to redesign or “modernize” something to proceed:
    - That is a signal that the change is out of scope for 0.2.5a.
    - Notify the user that the requested change appears to be a redesign, not a refactor.
    - Do not proceed until the user explicitly confirms they want a redesign.
